<html>
<head>
  <script type="text/javascript" src="demo-libs/Bacon.min.js"></script>
  <script type="text/javascript" src="http://localhost:35729/livereload.js"></script>
  <script type="text/javascript" src="form-validation-kit.js"></script>
  <style>
    li {
      list-style: none;
      padding: 10px;
    }
    .demo {
      display: block;
      padding: 5px;
      background-color: #EEE;
      white-space: pre;
      font-family: monospace;
      font-size: 11px;
    }
    body {
      max-width: 780px;
    }
    .queue {
      padding: 0;
      position: relative;
    }
    .queue:before {
      content: "State from new to old (left to right)";
      position: absolute;
      bottom: -20;
      margin: auto;
      font-size: 10px;
    }
    .queue li {
      display: inline-block;
      height: 20px;
      width: 30px;
      padding: 0;
      font-size: 9px;
      overflow: hidden;
      text-align: center;
      line-height: 20px;
    }
  </style>
</head>
<body onload="testInput()">
<script>
  var colors = {};
  colors[Validation.Error] = 'red';
  colors[Validation.Queued] = 'lightgray';
  colors[Validation.Validating] = 'aqua';
  colors[Validation.Valid] = 'lime';
  colors[Validation.Invalid] = 'pink';
  var queue = {};
  var maxQueue = 10;
  function visualize(element) {
    return function(response) {
      element.style.backgroundColor = colors[response.state];
      element.nextElementSibling.textContent = '[' + response.state + '] ' + response.errorMessages.join(", ");

      var id = element.nextElementSibling.nextElementSibling.id;
      if (queue[id] === undefined) {
        queue[id] = [];
      }
      queue[id].unshift(response.state);
      queue[id] = queue[id].slice(0, maxQueue);

      element.nextElementSibling.nextElementSibling.innerHTML = queue[id].map(function(state) {
        return '<li style="background-color: ' + colors[state] + '">' + state + "</li>";
      }).join("")
    }
  }
</script>
<h1>form-validation-kit</h1>
<p>form-validation-kit is a small library for handling the validation state of
  HTML forms.</p>
<p><a href="https://github.com/teijo/form-validation-kit">Project repository at Github</a></p>

<h2>Demo form</h2>
<p>Filled on reload. Modify the inputs and play around.</p>
<form autocomplete="off">
  <dl>
    <li>
      <p>textHandler()</p>
      <input id="textInput" type="text" onkeyup="textHandler(event)" />
      <label for="textInput"></label>
      <ul class="queue" id="textVisu"></ul>
    </li>
    <li>
      <p>numberHandler()</p>
      <input id="numberInput" type="text" onkeyup="numberHandler(event)"/>
      <label for="numberInput"></label>
      <ul class="queue" id="numberVisu"></ul>
    </li>
    <li>
      <p>failingHandler()</p>
      <input id="failingInput" type="text" onkeyup="failingHandler(event)"/>
      <label for="failingInput"></label>
      <ul class="queue" id="failingVisu"></ul>
    </li>
    <li>
      <input id="formSubmit" type="submit"/>
      <label for="formSubmit"></label>
      <ul class="queue" id="formVisu"></ul>
    </li>
  </dl>
</form>

<h2>Sample validators</h2>
<p>Validator is a function determining determining the validity of the
  received input. Completed validation is indicated with <code>done</code> or
  <code>error</code> callbacks. If input is deemed INVALID, given message is
  returned to the validation requester. If unexpected problem occurs, such as
  a timeout for AJAX call, ERROR state can be triggered with desired
  description. Low granularity validators can be can be combined together
  (see below).</p>

<script class="demo">
  function duplicateValidator(text) {
    return function(value, done) {
      setTimeout(function() {
        done(value !== text, 'Reserved word "' + text + '"');
      }, 50);
    }
  }

  function lengthValidator(minLength) {
    return function(value, done) {
      setTimeout(function() {
        done(value.length >= minLength, "Minimum length is " + minLength);
      }, 100);
    }
  }

  function regexpValidator(regexp) {
    return function(value, done) {
      done(value.match(regexp) !== null, "Not matching pattern " + regexp);
    }
  }

  function failingValidator(value, done, error) {
    setTimeout(function() {
      if (value.length > 5)
        error("Validation timed out, too long input");
      else
        done(true);
    }, 50);
  }
</script>

<h2>Demo form setup</h2>
<p><code>form</code> indicates a group of input <code>validator</code>s.
  <code>form</code> receives the combined state of the inputs, e.g. if one
  <code>validator</code> is INVALID and all others are VALID, combined result
  for the form is INVALID. If state of one <code>validator</code> is
  VALIDATING (result pending from asynchronous validation), state of
  <code>form</code> is VALIDATING. Precedence from first to last is listed below:</p>
<ol>
  <li>ERROR: Validator could not correctly determine the validity of the input</li>
  <li>QUEUED: Input received but validator invocation is waiting for throttle cooldown</li>
  <li>VALIDATING: Validator invoked with latest value and waiting for response</li>
  <li>INVALID: Validator has evaluated input as invalid</li>
  <li>VALID: Validator has evaluated input as valid</li>
</ol>

<script class="demo">
  var form = Validation.Create(function(state) {
    var submitButton = document.getElementById('formSubmit');
    submitButton.disabled = (state.state === Validation.Valid) ? '' : 'disabled';
    visualize(submitButton)(state);
  });

  // Validators build from combining earlier definitions
  var textValidation = form.register(duplicateValidator("Test"), lengthValidator(6));
  var numberValidation = form.register(regexpValidator(/^[0-9]*$/));
  var timeoutValidation = form.register(failingValidator, {throttle: 1000});

  function textHandler(event) {
    textValidation.evaluate(event.target.value, visualize(event.target));
  }

  function numberHandler(event) {
    numberValidation.evaluate(event.target.value, visualize(event.target));
  }

  function failingHandler(event) {
    timeoutValidation.evaluate(event.target.value, visualize(event.target));
  }
</script>
<script>
  function emulateTyping(elementId, testInput, interval) {
    var node = document.getElementById(elementId);
    Bacon.sequentially(interval, testInput.split("")).onValue(function(char) {
      var event = new Event("keyup");
      event.keyCode = char.charCodeAt(0);
      node.value = node.value + char;
      node.dispatchEvent(event);
    });
  }
  function testInput() {
    emulateTyping('textInput', "Test some long text", 150);
    emulateTyping('numberInput', "1234ABCD", 400);
    emulateTyping('failingInput', "timeout", 300);
  }
</script>
</body>
</html>
