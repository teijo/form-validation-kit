<html>
<head>
  <script type="text/javascript" src="bower_components/bacon/dist/Bacon.js"></script>
  <script type="text/javascript" src="http://localhost:35729/livereload.js"></script>
</head>
<body onload="emulateTyping()">
<form>
  <input id="textInput" type="text" name="textInput" onkeyup="input(event)" />
  <label id="textInputResult" for="textInput"></label>
</form>
<script>
  STATE_OK = 1;
  STATE_INVALID = 0;
  STATE_PENDING = -1;
  STATE_QUEUED = -2;

  function Validation(/*...validators*/) {
    var validatorList = Array.prototype.slice.call(arguments);
    var input = new Bacon.Bus();
    var throttledInput = input.throttle(100);

    var validationStream = throttledInput.flatMapLatest(function(value) {
      if (typeof(value) !== 'string') {
        throw new Error('Given input not string: ' + value)
      }
      return Bacon.combineAsArray(validatorList.map(function(validator) {
        return Bacon.fromCallback(function(done) {
          validator(value, function(isValid, errorMessage) {
            done({state: isValid ? STATE_OK : STATE_INVALID, errorMessage: errorMessage || ""});
          });
        });
      }));
    });

    var requestQueued = input.map({state: STATE_QUEUED, errorMessageList: []});
    var requestSent = throttledInput.map({state: STATE_PENDING, errorMessageList: []});
    var response = validationStream.map(function(responseList) {
      return responseList.reduce(function (agg, response) {
        if (response.state === STATE_INVALID) {
          agg.state = STATE_INVALID;
          agg.errorMessageList = agg.errorMessageList.concat(response.errorMessage);
        }
        return agg;
      }, {state: STATE_OK, errorMessageList: []});
    });

    var state = Bacon.mergeAll(
        requestQueued,
        requestSent,
        response
    ).skipDuplicates();

    function stateResolved(response) {
      return (response.state === STATE_INVALID || response.state === STATE_OK);
    }

    return {
      evaluate: function(value, cb) {
        state.subscribe(function(event) {
          var response = event.value();
          cb(response);
          return stateResolved(response) ? Bacon.noMore : Bacon.more;
        });
        input.push(value);
      }
    }
  }

  function duplicateValidator(value, done) {
    setTimeout(function() {
      done(value !== "Test", "Reserved text");
    }, 50);
  }

  function lengthValidator(value, done) {
    setTimeout(function() {
      done(value.length > 5, "Input too short");
    }, 100);
  }

  var inputElement = function() { return document.getElementById("textInput") };
  var inputResultElement = function() { return document.getElementById("textInputResult") };

  function stateChange(response) {
    var colors = {};
    colors[STATE_QUEUED] = 'lightgray';
    colors[STATE_PENDING] = 'aqua';
    colors[STATE_OK] = 'lime';
    colors[STATE_INVALID] = 'pink';
    inputElement().style.backgroundColor = colors[response.state];
    inputResultElement().innerText = response.errorMessageList.join(", ");
  }

  var validateLengthAndDuplicates = Validation(duplicateValidator, lengthValidator);

  function input(event) {
    validateLengthAndDuplicates.evaluate(event.target.value, stateChange);
  }

  function emulateTyping() {
    var node = inputElement();
    var testInput = "Test Input";
    Bacon.sequentially(200, testInput.split("")).onValue(function(char) {
      var event = new Event("keyup");
      event.keyCode = char.charCodeAt(0);
      node.value = node.value + char;
      node.dispatchEvent(event);
    });
  }
</script>
</body>
</html>
