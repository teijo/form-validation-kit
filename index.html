<html>
<head>
  <script type="text/javascript" src="bower_components/bacon/dist/Bacon.js"></script>
  <script type="text/javascript" src="http://localhost:35729/livereload.js"></script>
  <style>
    li {
      list-style: none;
      padding: 10px;
    }
  </style>
</head>
<body onload="emulateTyping()">
<form>
  <dl>
    <li>
      <input id="textInput" type="text" onkeyup="textInputHandler(event)" />
      <label for="textInput"></label>
    </li>
    <li>
      <input id="numberInput" type="text" onkeyup="numberInputHandler(event)"/>
      <label for="numberInput"></label>
    </li>
    <li>
      <input id="formSubmit" type="submit"/>
      <label for="formSubmit"></label>
    </li>
  </dl>
</form>
<script>
  var State = {
    OK: 1,
    INVALID: 0,
    PENDING: -1,
    QUEUED: -2
  };

  function Validation(/*...validators*/) {
    var validatorList = Array.prototype.slice.call(arguments);
    var input = new Bacon.Bus();
    var throttledInput = input.throttle(100);

    var validationStream = throttledInput.flatMapLatest(function(value) {
      return Bacon.combineAsArray(validatorList.map(function(validator) {
        return Bacon.fromCallback(function(done) {
          validator(value, function(isValid, errorMessage) {
            done({state: isValid ? State.OK : State.INVALID, errorMessage: errorMessage || ""});
          });
        });
      }));
    });

    var requestQueued = input.map({state: State.QUEUED, errorMessageList: []});
    var requestSent = throttledInput.map({state: State.PENDING, errorMessageList: []});
    var response = validationStream.map(function(responseList) {
      return responseList.reduce(function (agg, response) {
        if (response.state === State.INVALID) {
          agg.state = State.INVALID;
          agg.errorMessageList = agg.errorMessageList.concat(response.errorMessage);
        }
        return agg;
      }, {state: State.OK, errorMessageList: []});
    });

    var state = Bacon.mergeAll(
        requestQueued,
        requestSent,
        response
    ).skipDuplicates();

    function stateResolved(response) {
      return (response.state === State.INVALID || response.state === State.OK);
    }

    return {
      state: state.map('.state'),
      evaluate: function(value, cb) {
        state.subscribe(function(event) {
          var response = event.value();
          cb(response);
          return stateResolved(response) ? Bacon.noMore : Bacon.more;
        });
        input.push(value);
      }
    }
  }

  function duplicateValidator(text) {
    return function(value, done) {
      setTimeout(function() {
        done(value !== text, 'Reserved word "' + text + '"');
      }, 50);
    }
  }

  function lengthValidator(minLength) {
    return function(value, done) {
      setTimeout(function() {
        done(value.length >= minLength, "Minimum length is " + minLength);
      }, 100);
    }
  }

  function regexpValidator(regexp) {
    return function(value, done) {
      done(value.match(regexp) !== null, "Not matching pattern " + regexp);
    }
  }

  function visualize(element) {
    return function(response) {
      var colors = {};
      colors[State.QUEUED] = 'lightgray';
      colors[State.PENDING] = 'aqua';
      colors[State.OK] = 'lime';
      colors[State.INVALID] = 'pink';
      element.style.backgroundColor = colors[response.state];
      element.nextElementSibling.textContent = response.errorMessageList.join(", ");
    }
  }

  function Form(stateCallback) {
    var stateStreams = [];
    function addValidatorStateStream(stateStream) {
      stateStreams.push(stateStream);
      Bacon.combineAsArray(stateStreams).map(function(validators) {
        var PRECEDENCE = [State.QUEUED, State.PENDING, State.INVALID, State.OK];
        return validators.reduce(function(agg, state) {
          return (PRECEDENCE.indexOf(state) < PRECEDENCE.indexOf(agg)) ? state : agg;
        })
      }).map(function(combinedState) {
        return {state: combinedState, errorMessageList: []};
      }).skipDuplicates().onValue(stateCallback);
    }

    addValidatorStateStream(Bacon.constant(State.OK));

    return {
      validator: function() {
        var validator = Validation.apply(this, arguments);
        addValidatorStateStream(validator.state);
        return {evaluate: validator.evaluate};
      }
    }
  }

  function button() {
    var element = document.getElementById('formSubmit');
    var handler = visualize(element);
    return function(state) {
      element.disabled = (state.state === State.OK) ? '' : 'disabled';
      handler(state);
    }
  }

  var form = Form(button());

  var validateLengthAndDuplicates = form.validator(duplicateValidator("Test"), lengthValidator(6));
  var validateNumber = form.validator(regexpValidator(/^[0-9]*$/), lengthValidator(2));

  function textInputHandler(event) {
    validateLengthAndDuplicates.evaluate(event.target.value, visualize(event.target));
  }

  function numberInputHandler(event) {
    validateNumber.evaluate(event.target.value, visualize(event.target));
  }

  function emulateTyping() {
    var node = document.getElementById("textInput");
    var testInput = "Test Input";
    Bacon.sequentially(200, testInput.split("")).onValue(function(char) {
      var event = new Event("keyup");
      event.keyCode = char.charCodeAt(0);
      node.value = node.value + char;
      node.dispatchEvent(event);
    });
  }
</script>
</body>
</html>
